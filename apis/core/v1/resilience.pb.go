// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.0
// source: core/v1/resilience.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	kernel "github.com/aileron-gateway/aileron-gateway/apis/kernel"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// LBAlgorithm is the load balance algorithm.
type LBAlgorithm int32

const (
	LBAlgorithm_RoundRobin LBAlgorithm = 0 // Round-robin algorithm.
	LBAlgorithm_Random     LBAlgorithm = 1 // Random algorithm.
	LBAlgorithm_RingHash   LBAlgorithm = 2 // RingHash algorithm.
	LBAlgorithm_Maglev     LBAlgorithm = 3 // Maglev algorithm.
	LBAlgorithm_DirectHash LBAlgorithm = 4 // DirectHash algorithm.
)

// Enum value maps for LBAlgorithm.
var (
	LBAlgorithm_name = map[int32]string{
		0: "RoundRobin",
		1: "Random",
		2: "RingHash",
		3: "Maglev",
		4: "DirectHash",
	}
	LBAlgorithm_value = map[string]int32{
		"RoundRobin": 0,
		"Random":     1,
		"RingHash":   2,
		"Maglev":     3,
		"DirectHash": 4,
	}
)

func (x LBAlgorithm) Enum() *LBAlgorithm {
	p := new(LBAlgorithm)
	*p = x
	return p
}

func (x LBAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LBAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_core_v1_resilience_proto_enumTypes[0].Descriptor()
}

func (LBAlgorithm) Type() protoreflect.EnumType {
	return &file_core_v1_resilience_proto_enumTypes[0]
}

func (x LBAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LBAlgorithm.Descriptor instead.
func (LBAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{0}
}

// HTTPHasherType is the hashing method types
// which calculate hash values from HTTP requests.
type HTTPHasherType int32

const (
	HTTPHasherType_ClientAddr  HTTPHasherType = 0 // ClientAddr hasher hashes client IP:Port.
	HTTPHasherType_Header      HTTPHasherType = 1 // Header hasher hashed single HTTP header.
	HTTPHasherType_MultiHeader HTTPHasherType = 2 // MultiHeader hasher hashed multiple HTTP headers.
	HTTPHasherType_Cookie      HTTPHasherType = 3 // Cookie hasher hashed cookie value.
	HTTPHasherType_Query       HTTPHasherType = 4 // Query hasher hashed URL query parameter.
	HTTPHasherType_PathParam   HTTPHasherType = 5 // PathParam hasher hashed path parameter.
)

// Enum value maps for HTTPHasherType.
var (
	HTTPHasherType_name = map[int32]string{
		0: "ClientAddr",
		1: "Header",
		2: "MultiHeader",
		3: "Cookie",
		4: "Query",
		5: "PathParam",
	}
	HTTPHasherType_value = map[string]int32{
		"ClientAddr":  0,
		"Header":      1,
		"MultiHeader": 2,
		"Cookie":      3,
		"Query":       4,
		"PathParam":   5,
	}
)

func (x HTTPHasherType) Enum() *HTTPHasherType {
	p := new(HTTPHasherType)
	*p = x
	return p
}

func (x HTTPHasherType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HTTPHasherType) Descriptor() protoreflect.EnumDescriptor {
	return file_core_v1_resilience_proto_enumTypes[1].Descriptor()
}

func (HTTPHasherType) Type() protoreflect.EnumType {
	return &file_core_v1_resilience_proto_enumTypes[1]
}

func (x HTTPHasherType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HTTPHasherType.Descriptor instead.
func (HTTPHasherType) EnumDescriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{1}
}

// WaiterSpec is the specification for waiter object.
type WaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Waiter:
	//
	//	*WaiterSpec_FixedBackoff
	//	*WaiterSpec_LinearBackoff
	//	*WaiterSpec_PolynomialBackoff
	//	*WaiterSpec_ExponentialBackoff
	//	*WaiterSpec_ExponentialBackoffFullJitter
	//	*WaiterSpec_ExponentialBackoffEqualJitter
	Waiter        isWaiterSpec_Waiter `protobuf_oneof:"Waiter"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WaiterSpec) Reset() {
	*x = WaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WaiterSpec) ProtoMessage() {}

func (x *WaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WaiterSpec.ProtoReflect.Descriptor instead.
func (*WaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{0}
}

func (x *WaiterSpec) GetWaiter() isWaiterSpec_Waiter {
	if x != nil {
		return x.Waiter
	}
	return nil
}

func (x *WaiterSpec) GetFixedBackoff() *FixedBackoffWaiterSpec {
	if x != nil {
		if x, ok := x.Waiter.(*WaiterSpec_FixedBackoff); ok {
			return x.FixedBackoff
		}
	}
	return nil
}

func (x *WaiterSpec) GetLinearBackoff() *LinearBackoffWaiterSpec {
	if x != nil {
		if x, ok := x.Waiter.(*WaiterSpec_LinearBackoff); ok {
			return x.LinearBackoff
		}
	}
	return nil
}

func (x *WaiterSpec) GetPolynomialBackoff() *PolynomialBackoffWaiterSpec {
	if x != nil {
		if x, ok := x.Waiter.(*WaiterSpec_PolynomialBackoff); ok {
			return x.PolynomialBackoff
		}
	}
	return nil
}

func (x *WaiterSpec) GetExponentialBackoff() *ExponentialBackoffWaiterSpec {
	if x != nil {
		if x, ok := x.Waiter.(*WaiterSpec_ExponentialBackoff); ok {
			return x.ExponentialBackoff
		}
	}
	return nil
}

func (x *WaiterSpec) GetExponentialBackoffFullJitter() *ExponentialBackoffFullJitterWaiterSpec {
	if x != nil {
		if x, ok := x.Waiter.(*WaiterSpec_ExponentialBackoffFullJitter); ok {
			return x.ExponentialBackoffFullJitter
		}
	}
	return nil
}

func (x *WaiterSpec) GetExponentialBackoffEqualJitter() *ExponentialBackoffEqualJitterWaiterSpec {
	if x != nil {
		if x, ok := x.Waiter.(*WaiterSpec_ExponentialBackoffEqualJitter); ok {
			return x.ExponentialBackoffEqualJitter
		}
	}
	return nil
}

type isWaiterSpec_Waiter interface {
	isWaiterSpec_Waiter()
}

type WaiterSpec_FixedBackoff struct {
	// [OPTIONAL]
	// FixedBackoff is the confguration for FixedBackoffWaiter.
	FixedBackoff *FixedBackoffWaiterSpec `protobuf:"bytes,1,opt,name=FixedBackoff,json=fixedBackoff,proto3,oneof"`
}

type WaiterSpec_LinearBackoff struct {
	// [OPTIONAL]
	// FixedBackoff is the confguration for LinearBackoffWaiter.
	LinearBackoff *LinearBackoffWaiterSpec `protobuf:"bytes,2,opt,name=LinearBackoff,json=linearBackoff,proto3,oneof"`
}

type WaiterSpec_PolynomialBackoff struct {
	// [OPTIONAL]
	// FixedBackoff is the confguration for PolynomialBackoffWaiter.
	PolynomialBackoff *PolynomialBackoffWaiterSpec `protobuf:"bytes,3,opt,name=PolynomialBackoff,json=polynomialBackoff,proto3,oneof"`
}

type WaiterSpec_ExponentialBackoff struct {
	// [OPTIONAL]
	// FixedBackoff is the confguration for ExponentialBackoffWaiter.
	ExponentialBackoff *ExponentialBackoffWaiterSpec `protobuf:"bytes,4,opt,name=ExponentialBackoff,json=exponentialBackoff,proto3,oneof"`
}

type WaiterSpec_ExponentialBackoffFullJitter struct {
	// [OPTIONAL]
	// FixedBackoff is the confguration for ExponentialBackoffFullJitterWaiter.
	ExponentialBackoffFullJitter *ExponentialBackoffFullJitterWaiterSpec `protobuf:"bytes,5,opt,name=ExponentialBackoffFullJitter,json=exponentialBackoffFullJitter,proto3,oneof"`
}

type WaiterSpec_ExponentialBackoffEqualJitter struct {
	// [OPTIONAL]
	// ExponentialBackoffEqualJitter is the confguration for ExponentialBackoffEqualJitterWaiter.
	ExponentialBackoffEqualJitter *ExponentialBackoffEqualJitterWaiterSpec `protobuf:"bytes,6,opt,name=ExponentialBackoffEqualJitter,json=exponentialBackoffEqualJitter,proto3,oneof"`
}

func (*WaiterSpec_FixedBackoff) isWaiterSpec_Waiter() {}

func (*WaiterSpec_LinearBackoff) isWaiterSpec_Waiter() {}

func (*WaiterSpec_PolynomialBackoff) isWaiterSpec_Waiter() {}

func (*WaiterSpec_ExponentialBackoff) isWaiterSpec_Waiter() {}

func (*WaiterSpec_ExponentialBackoffFullJitter) isWaiterSpec_Waiter() {}

func (*WaiterSpec_ExponentialBackoffEqualJitter) isWaiterSpec_Waiter() {}

// FixedBackoffWaiterSpec is the specification for waiter of fixed backoff algorithm.
// 1st=base, 2nd=base, 3rd=base, ....
type FixedBackoffWaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// Base is the base duration to wait until the next request in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [5000] or 5 milliseconds.
	Base          int32 `protobuf:"varint,1,opt,name=Base,json=base,proto3" json:"Base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FixedBackoffWaiterSpec) Reset() {
	*x = FixedBackoffWaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FixedBackoffWaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FixedBackoffWaiterSpec) ProtoMessage() {}

func (x *FixedBackoffWaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FixedBackoffWaiterSpec.ProtoReflect.Descriptor instead.
func (*FixedBackoffWaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{1}
}

func (x *FixedBackoffWaiterSpec) GetBase() int32 {
	if x != nil {
		return x.Base
	}
	return 0
}

// FixedBackoffWaiterSpec is the specification for waiter of linear backoff algorithm.
// Wait duration after n-th request will be sent after dt=[base * n] microseconds.
// 1st=base, 2nd=2*base, 3rd=3*base, ....
type LinearBackoffWaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// Base is the base duration to wait until the next request in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [5000] or 5 milliseconds.
	Base int32 `protobuf:"varint,1,opt,name=Base,json=base,proto3" json:"Base,omitempty"`
	// [OPTIONAL]
	// Min is the minimum wait duration in microsecond.
	// Default is [0].
	Min int32 `protobuf:"varint,2,opt,name=Min,json=min,proto3" json:"Min,omitempty"`
	// [OPTIONAL]
	// Max is the maximum wait duration in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2097152], or about 2.1 seconds.
	Max           int32 `protobuf:"varint,3,opt,name=Max,json=max,proto3" json:"Max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LinearBackoffWaiterSpec) Reset() {
	*x = LinearBackoffWaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LinearBackoffWaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearBackoffWaiterSpec) ProtoMessage() {}

func (x *LinearBackoffWaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearBackoffWaiterSpec.ProtoReflect.Descriptor instead.
func (*LinearBackoffWaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{2}
}

func (x *LinearBackoffWaiterSpec) GetBase() int32 {
	if x != nil {
		return x.Base
	}
	return 0
}

func (x *LinearBackoffWaiterSpec) GetMin() int32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *LinearBackoffWaiterSpec) GetMax() int32 {
	if x != nil {
		return x.Max
	}
	return 0
}

// PolynomialBackoffWaiterSpec is the specification for waiter of polynomial backoff algorithm.
// Wait duration after n-th request will be sent after dt=[base*n^exponent] microseconds.
// 1st=base, 2nd=base*2^exponent, 3rd=base*3^exponent, ....
type PolynomialBackoffWaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// Base is the base duration to wait until the next request in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [5000] or 5 milliseconds.
	Base int32 `protobuf:"varint,1,opt,name=Base,json=base,proto3" json:"Base,omitempty"`
	// [OPTIONAL]
	// Min is the minimum wait duration in microsecond.
	// Default is [0].
	Min int32 `protobuf:"varint,2,opt,name=Min,json=min,proto3" json:"Min,omitempty"`
	// [OPTIONAL]
	// Max is the maximum wait duration in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2097152], or about 2.1 seconds.
	Max int32 `protobuf:"varint,3,opt,name=Max,json=max,proto3" json:"Max,omitempty"`
	// [OPTIONAL]
	// Exponent is the exponent number used to calculate wait duration.
	// Default value is used when this field is set to 0.
	// Default is [2].
	Exponent      int32 `protobuf:"varint,4,opt,name=Exponent,json=exponent,proto3" json:"Exponent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PolynomialBackoffWaiterSpec) Reset() {
	*x = PolynomialBackoffWaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PolynomialBackoffWaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolynomialBackoffWaiterSpec) ProtoMessage() {}

func (x *PolynomialBackoffWaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolynomialBackoffWaiterSpec.ProtoReflect.Descriptor instead.
func (*PolynomialBackoffWaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{3}
}

func (x *PolynomialBackoffWaiterSpec) GetBase() int32 {
	if x != nil {
		return x.Base
	}
	return 0
}

func (x *PolynomialBackoffWaiterSpec) GetMin() int32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *PolynomialBackoffWaiterSpec) GetMax() int32 {
	if x != nil {
		return x.Max
	}
	return 0
}

func (x *PolynomialBackoffWaiterSpec) GetExponent() int32 {
	if x != nil {
		return x.Exponent
	}
	return 0
}

// ExponentialBackoffWaiterSpec is the specification for waiter of exponential backoff algorithm.
// Wait duration after n-th request will be sent after dt=[base*2^n] microseconds.
// 1st=2*base, 2nd=4*base, 3rd=9*base, ....
type ExponentialBackoffWaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// Base is the base duration to wait until the next request in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2000] or 2 milliseconds.
	Base int32 `protobuf:"varint,1,opt,name=Base,json=base,proto3" json:"Base,omitempty"`
	// [OPTIONAL]
	// Min is the minimum wait duration in microsecond.
	// Default is [0].
	Min int32 `protobuf:"varint,2,opt,name=Min,json=min,proto3" json:"Min,omitempty"`
	// [OPTIONAL]
	// Max is the maximum wait duration in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2097152], or about 2.1 seconds.
	Max           int32 `protobuf:"varint,3,opt,name=Max,json=max,proto3" json:"Max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExponentialBackoffWaiterSpec) Reset() {
	*x = ExponentialBackoffWaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExponentialBackoffWaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExponentialBackoffWaiterSpec) ProtoMessage() {}

func (x *ExponentialBackoffWaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExponentialBackoffWaiterSpec.ProtoReflect.Descriptor instead.
func (*ExponentialBackoffWaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{4}
}

func (x *ExponentialBackoffWaiterSpec) GetBase() int32 {
	if x != nil {
		return x.Base
	}
	return 0
}

func (x *ExponentialBackoffWaiterSpec) GetMin() int32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *ExponentialBackoffWaiterSpec) GetMax() int32 {
	if x != nil {
		return x.Max
	}
	return 0
}

// ExponentialBackoffFullJitterWaiterSpec is the specification for waiter of exponential backoff with full jitter algorithm.
// Wait duration after n-th request will be sent after dt=random(0, base*2^n) microseconds.
// 1st=random(0, 2*base), 2nd=random(0, 4*base), 3rd=random(0, 9*base), ....
type ExponentialBackoffFullJitterWaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// Base is the base duration to wait until the next request in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2000] or 2 milliseconds.
	Base int32 `protobuf:"varint,1,opt,name=Base,json=base,proto3" json:"Base,omitempty"`
	// [OPTIONAL]
	// Min is the minimum wait duration in microsecond.
	// Default is [0].
	Min int32 `protobuf:"varint,2,opt,name=Min,json=min,proto3" json:"Min,omitempty"`
	// [OPTIONAL]
	// Max is the maximum wait duration in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2097152], or about 2.1 seconds.
	Max           int32 `protobuf:"varint,3,opt,name=Max,json=max,proto3" json:"Max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExponentialBackoffFullJitterWaiterSpec) Reset() {
	*x = ExponentialBackoffFullJitterWaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExponentialBackoffFullJitterWaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExponentialBackoffFullJitterWaiterSpec) ProtoMessage() {}

func (x *ExponentialBackoffFullJitterWaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExponentialBackoffFullJitterWaiterSpec.ProtoReflect.Descriptor instead.
func (*ExponentialBackoffFullJitterWaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{5}
}

func (x *ExponentialBackoffFullJitterWaiterSpec) GetBase() int32 {
	if x != nil {
		return x.Base
	}
	return 0
}

func (x *ExponentialBackoffFullJitterWaiterSpec) GetMin() int32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *ExponentialBackoffFullJitterWaiterSpec) GetMax() int32 {
	if x != nil {
		return x.Max
	}
	return 0
}

// ExponentialBackoffEqualJitterWaiterSpec is the specification for waiter of exponential backoff with equal jitter algorithm.
// Wait duration after n-th request will be sent after dt=0.5*base*2^n+random(0, 0.5*base*2^n) microseconds.
// 1st=base+random(0, base), 2nd=2*base+random(0, 2*base), 3rd=4.5*base+random(0, 4.5*base), ....
type ExponentialBackoffEqualJitterWaiterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// Base is the base duration to wait until the next request in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2000] or 2 milliseconds.
	Base int32 `protobuf:"varint,1,opt,name=Base,json=base,proto3" json:"Base,omitempty"`
	// [OPTIONAL]
	// Min is the minimum wait duration in microsecond.
	// Default is [0].
	Min int32 `protobuf:"varint,2,opt,name=Min,json=min,proto3" json:"Min,omitempty"`
	// [OPTIONAL]
	// Max is the maximum wait duration in microsecond.
	// Default value is used when this field is set to 0.
	// Default is [2097152], or about 2.1 seconds.
	Max           int32 `protobuf:"varint,3,opt,name=Max,json=max,proto3" json:"Max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExponentialBackoffEqualJitterWaiterSpec) Reset() {
	*x = ExponentialBackoffEqualJitterWaiterSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExponentialBackoffEqualJitterWaiterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExponentialBackoffEqualJitterWaiterSpec) ProtoMessage() {}

func (x *ExponentialBackoffEqualJitterWaiterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExponentialBackoffEqualJitterWaiterSpec.ProtoReflect.Descriptor instead.
func (*ExponentialBackoffEqualJitterWaiterSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{6}
}

func (x *ExponentialBackoffEqualJitterWaiterSpec) GetBase() int32 {
	if x != nil {
		return x.Base
	}
	return 0
}

func (x *ExponentialBackoffEqualJitterWaiterSpec) GetMin() int32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *ExponentialBackoffEqualJitterWaiterSpec) GetMax() int32 {
	if x != nil {
		return x.Max
	}
	return 0
}

// HTTPHasherSpec is the specifications for hasher
// that calculate hashes from http requests.
// RingHash, Maglev and DirectHash.
type HTTPHasherSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [OPTIONAL]
	// HasherType is the hashing type to use.
	// This field is used by hash-based load balancers.
	// Non hash-based load balancers ignore this field.
	// Currently,  RingHash, Maglev and DirectHash
	// are the hash-based load balancer.
	// Default is ["ClientAddr"].
	HasherType HTTPHasherType `protobuf:"varint,1,opt,name=HasherType,json=hasherType,proto3,enum=core.v1.HTTPHasherType" json:"HasherType,omitempty"`
	// [OPTIONAL]
	// HashAlg is the algorithm used by the hasher.
	// This field is used by hash-based load balancers.
	// Non hash-based load balancers ignore this field.
	// Currently,  RingHash, Maglev and DirectHash
	// are the hash-based load balancer.
	// A lightweight and non-cryptgraphic algorithm is recommended for
	// better performance.
	// FNV1_32 or FNV1a_32 are recommended algorithms.
	// If not set, default algorithm is used.
	// Default is ["FNV1a_32"].
	HashAlg kernel.HashAlg `protobuf:"varint,2,opt,name=HashAlg,json=hashAlg,proto3,enum=kernel.HashAlg" json:"HashAlg,omitempty"`
	// [OPTIONAL]
	// Key is the data source key.
	// This is the header name for Header hasher,
	// query parameter name for Query hasher
	// and path parameter name for PathParam hasher.
	// ClientAddr and MultiHeader hasher ignore this field.
	// This field is optional but set non empty string for
	// Header, Query and PathParam hashers.
	// Default is not set.
	Key string `protobuf:"bytes,3,opt,name=Key,json=key,proto3" json:"Key,omitempty"`
	// [OPTIONAL]
	// Keys are the data source keys.
	// This is the header names for MultiHeader hasher.
	// Other hashers ignore this field.
	// This field is optional but should be set atleast 1
	// for MultiHeader hashers.
	// Default is not set.
	Keys          []string `protobuf:"bytes,4,rep,name=Keys,json=keys,proto3" json:"Keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPHasherSpec) Reset() {
	*x = HTTPHasherSpec{}
	mi := &file_core_v1_resilience_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPHasherSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPHasherSpec) ProtoMessage() {}

func (x *HTTPHasherSpec) ProtoReflect() protoreflect.Message {
	mi := &file_core_v1_resilience_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPHasherSpec.ProtoReflect.Descriptor instead.
func (*HTTPHasherSpec) Descriptor() ([]byte, []int) {
	return file_core_v1_resilience_proto_rawDescGZIP(), []int{7}
}

func (x *HTTPHasherSpec) GetHasherType() HTTPHasherType {
	if x != nil {
		return x.HasherType
	}
	return HTTPHasherType_ClientAddr
}

func (x *HTTPHasherSpec) GetHashAlg() kernel.HashAlg {
	if x != nil {
		return x.HashAlg
	}
	return kernel.HashAlg(0)
}

func (x *HTTPHasherSpec) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *HTTPHasherSpec) GetKeys() []string {
	if x != nil {
		return x.Keys
	}
	return nil
}

var File_core_v1_resilience_proto protoreflect.FileDescriptor

const file_core_v1_resilience_proto_rawDesc = "" +
	"\n" +
	"\x18core/v1/resilience.proto\x12\acore.v1\x1a\x1bbuf/validate/validate.proto\x1a\x11kernel/hash.proto\"\xc7\x04\n" +
	"\n" +
	"WaiterSpec\x12E\n" +
	"\fFixedBackoff\x18\x01 \x01(\v2\x1f.core.v1.FixedBackoffWaiterSpecH\x00R\ffixedBackoff\x12H\n" +
	"\rLinearBackoff\x18\x02 \x01(\v2 .core.v1.LinearBackoffWaiterSpecH\x00R\rlinearBackoff\x12T\n" +
	"\x11PolynomialBackoff\x18\x03 \x01(\v2$.core.v1.PolynomialBackoffWaiterSpecH\x00R\x11polynomialBackoff\x12W\n" +
	"\x12ExponentialBackoff\x18\x04 \x01(\v2%.core.v1.ExponentialBackoffWaiterSpecH\x00R\x12exponentialBackoff\x12u\n" +
	"\x1cExponentialBackoffFullJitter\x18\x05 \x01(\v2/.core.v1.ExponentialBackoffFullJitterWaiterSpecH\x00R\x1cexponentialBackoffFullJitter\x12x\n" +
	"\x1dExponentialBackoffEqualJitter\x18\x06 \x01(\v20.core.v1.ExponentialBackoffEqualJitterWaiterSpecH\x00R\x1dexponentialBackoffEqualJitterB\b\n" +
	"\x06Waiter\"5\n" +
	"\x16FixedBackoffWaiterSpec\x12\x1b\n" +
	"\x04Base\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00R\x04base\"l\n" +
	"\x17LinearBackoffWaiterSpec\x12\x1b\n" +
	"\x04Base\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00R\x04base\x12\x19\n" +
	"\x03Min\x18\x02 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03min\x12\x19\n" +
	"\x03Max\x18\x03 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03max\"\x95\x01\n" +
	"\x1bPolynomialBackoffWaiterSpec\x12\x1b\n" +
	"\x04Base\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00R\x04base\x12\x19\n" +
	"\x03Min\x18\x02 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03min\x12\x19\n" +
	"\x03Max\x18\x03 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03max\x12#\n" +
	"\bExponent\x18\x04 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\bexponent\"q\n" +
	"\x1cExponentialBackoffWaiterSpec\x12\x1b\n" +
	"\x04Base\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00R\x04base\x12\x19\n" +
	"\x03Min\x18\x02 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03min\x12\x19\n" +
	"\x03Max\x18\x03 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03max\"{\n" +
	"&ExponentialBackoffFullJitterWaiterSpec\x12\x1b\n" +
	"\x04Base\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00R\x04base\x12\x19\n" +
	"\x03Min\x18\x02 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03min\x12\x19\n" +
	"\x03Max\x18\x03 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03max\"|\n" +
	"'ExponentialBackoffEqualJitterWaiterSpec\x12\x1b\n" +
	"\x04Base\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00R\x04base\x12\x19\n" +
	"\x03Min\x18\x02 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03min\x12\x19\n" +
	"\x03Max\x18\x03 \x01(\x05B\a\xbaH\x04\x1a\x02(\x00R\x03max\"\x9a\x01\n" +
	"\x0eHTTPHasherSpec\x127\n" +
	"\n" +
	"HasherType\x18\x01 \x01(\x0e2\x17.core.v1.HTTPHasherTypeR\n" +
	"hasherType\x12)\n" +
	"\aHashAlg\x18\x02 \x01(\x0e2\x0f.kernel.HashAlgR\ahashAlg\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03key\x12\x12\n" +
	"\x04Keys\x18\x04 \x03(\tR\x04keys*S\n" +
	"\vLBAlgorithm\x12\x0e\n" +
	"\n" +
	"RoundRobin\x10\x00\x12\n" +
	"\n" +
	"\x06Random\x10\x01\x12\f\n" +
	"\bRingHash\x10\x02\x12\n" +
	"\n" +
	"\x06Maglev\x10\x03\x12\x0e\n" +
	"\n" +
	"DirectHash\x10\x04*c\n" +
	"\x0eHTTPHasherType\x12\x0e\n" +
	"\n" +
	"ClientAddr\x10\x00\x12\n" +
	"\n" +
	"\x06Header\x10\x01\x12\x0f\n" +
	"\vMultiHeader\x10\x02\x12\n" +
	"\n" +
	"\x06Cookie\x10\x03\x12\t\n" +
	"\x05Query\x10\x04\x12\r\n" +
	"\tPathParam\x10\x05B9Z7github.com/aileron-gateway/aileron-gateway/apis/core/v1b\x06proto3"

var (
	file_core_v1_resilience_proto_rawDescOnce sync.Once
	file_core_v1_resilience_proto_rawDescData []byte
)

func file_core_v1_resilience_proto_rawDescGZIP() []byte {
	file_core_v1_resilience_proto_rawDescOnce.Do(func() {
		file_core_v1_resilience_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_core_v1_resilience_proto_rawDesc), len(file_core_v1_resilience_proto_rawDesc)))
	})
	return file_core_v1_resilience_proto_rawDescData
}

var file_core_v1_resilience_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_core_v1_resilience_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_core_v1_resilience_proto_goTypes = []any{
	(LBAlgorithm)(0),                                // 0: core.v1.LBAlgorithm
	(HTTPHasherType)(0),                             // 1: core.v1.HTTPHasherType
	(*WaiterSpec)(nil),                              // 2: core.v1.WaiterSpec
	(*FixedBackoffWaiterSpec)(nil),                  // 3: core.v1.FixedBackoffWaiterSpec
	(*LinearBackoffWaiterSpec)(nil),                 // 4: core.v1.LinearBackoffWaiterSpec
	(*PolynomialBackoffWaiterSpec)(nil),             // 5: core.v1.PolynomialBackoffWaiterSpec
	(*ExponentialBackoffWaiterSpec)(nil),            // 6: core.v1.ExponentialBackoffWaiterSpec
	(*ExponentialBackoffFullJitterWaiterSpec)(nil),  // 7: core.v1.ExponentialBackoffFullJitterWaiterSpec
	(*ExponentialBackoffEqualJitterWaiterSpec)(nil), // 8: core.v1.ExponentialBackoffEqualJitterWaiterSpec
	(*HTTPHasherSpec)(nil),                          // 9: core.v1.HTTPHasherSpec
	(kernel.HashAlg)(0),                             // 10: kernel.HashAlg
}
var file_core_v1_resilience_proto_depIdxs = []int32{
	3,  // 0: core.v1.WaiterSpec.FixedBackoff:type_name -> core.v1.FixedBackoffWaiterSpec
	4,  // 1: core.v1.WaiterSpec.LinearBackoff:type_name -> core.v1.LinearBackoffWaiterSpec
	5,  // 2: core.v1.WaiterSpec.PolynomialBackoff:type_name -> core.v1.PolynomialBackoffWaiterSpec
	6,  // 3: core.v1.WaiterSpec.ExponentialBackoff:type_name -> core.v1.ExponentialBackoffWaiterSpec
	7,  // 4: core.v1.WaiterSpec.ExponentialBackoffFullJitter:type_name -> core.v1.ExponentialBackoffFullJitterWaiterSpec
	8,  // 5: core.v1.WaiterSpec.ExponentialBackoffEqualJitter:type_name -> core.v1.ExponentialBackoffEqualJitterWaiterSpec
	1,  // 6: core.v1.HTTPHasherSpec.HasherType:type_name -> core.v1.HTTPHasherType
	10, // 7: core.v1.HTTPHasherSpec.HashAlg:type_name -> kernel.HashAlg
	8,  // [8:8] is the sub-list for method output_type
	8,  // [8:8] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_core_v1_resilience_proto_init() }
func file_core_v1_resilience_proto_init() {
	if File_core_v1_resilience_proto != nil {
		return
	}
	file_core_v1_resilience_proto_msgTypes[0].OneofWrappers = []any{
		(*WaiterSpec_FixedBackoff)(nil),
		(*WaiterSpec_LinearBackoff)(nil),
		(*WaiterSpec_PolynomialBackoff)(nil),
		(*WaiterSpec_ExponentialBackoff)(nil),
		(*WaiterSpec_ExponentialBackoffFullJitter)(nil),
		(*WaiterSpec_ExponentialBackoffEqualJitter)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_core_v1_resilience_proto_rawDesc), len(file_core_v1_resilience_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_core_v1_resilience_proto_goTypes,
		DependencyIndexes: file_core_v1_resilience_proto_depIdxs,
		EnumInfos:         file_core_v1_resilience_proto_enumTypes,
		MessageInfos:      file_core_v1_resilience_proto_msgTypes,
	}.Build()
	File_core_v1_resilience_proto = out.File
	file_core_v1_resilience_proto_goTypes = nil
	file_core_v1_resilience_proto_depIdxs = nil
}
