// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The AILERON Gateway Authors

package encoder

import (
	"encoding/base32"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"regexp"
	"testing"

	k "github.com/aileron-gateway/aileron-gateway/apis/kernel"
	"github.com/aileron-gateway/aileron-gateway/kernel/er"
	"github.com/aileron-gateway/aileron-gateway/kernel/testutil"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

func TestBase16Encode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		// expected value can be generated by the following command on a linux.
		// echo -n "0123456789" | basenc --base16 -
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "30313233343536373839",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "6162636465666768696a6b6c6d6e6f707172737475767778797a",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "4142434445464748494a4b4c4d4e4f505152535455565758595a",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base16 -
				encoded: "202122232425262728292a2b2c2d2e2f3a3b3c3d3e3f405b5c5d5e5f607b7c7d7e",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base16Encode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase16Decode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "30313233343536373839",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "6162636465666768696a6b6c6d6e6f707172737475767778797a",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "4142434445464748494a4b4c4d4e4f505152535455565758595a",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "202122232425262728292a2b2c2d2e2f3a3b3c3d3e3f405b5c5d5e5f607b7c7d7e",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase16,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base16Decode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase32Encode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		// expected value can be generated by the following command on a linux.
		// echo -n "0123456789" | basenc --base32 -
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "GAYTEMZUGU3DOOBZ",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "MFRGGZDFMZTWQ2LKNNWG23TPOBYXE43UOV3HO6DZPI======",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "IFBEGRCFIZDUQSKKJNGE2TSPKBIVEU2UKVLFOWCZLI======",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base32 -
				encoded: "EAQSEIZEEUTCOKBJFIVSYLJOF45DWPB5HY7UAW24LVPF6YD3PR6X4===",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base32Encode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase32Decode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "GAYTEMZUGU3DOOBZ",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "MFRGGZDFMZTWQ2LKNNWG23TPOBYXE43UOV3HO6DZPI======",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "IFBEGRCFIZDUQSKKJNGE2TSPKBIVEU2UKVLFOWCZLI======",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "EAQSEIZEEUTCOKBJFIVSYLJOF45DWPB5HY7UAW24LVPF6YD3PR6X4===",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase32,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base32Decode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase32EscapedEncode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "JB2XGQ3YJY5FSSC3",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "QHVJJ3FHQ3X0U4PNRR0J45XTSC21G65YSZ5KS8F3TL======",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "LHCGJVDHL3FYUWNNMRJG4XWTNCLZGY4YNZPHS0D3PL======",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				encoded: "GBUWGL3GGYXDSNCMHLZW2PMSH67F0TC7K29YB046PZTH82F5TV816===",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base32EscapedEncode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase32EscapedDecode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "JB2XGQ3YJY5FSSC3",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "QHVJJ3FHQ3X0U4PNRR0J45XTSC21G65YSZ5KS8F3TL======",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "LHCGJVDHL3FYUWNNMRJG4XWTNCLZGY4YNZPHS0D3PL======",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "GBUWGL3GGYXDSNCMHLZW2PMSH67F0TC7K29YB046PZTH82F5TV816===",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase32,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base32EscapedDecode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase32HexEncode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		// expected value can be generated by the following command on a linux.
		// echo -n "0123456789" | basenc --base32hex -
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "60OJ4CPK6KR3EE1P",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "C5H66P35CPJMGQBADDM6QRJFE1ON4SRKELR7EU3PF8======",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "85146H258P3KGIAA9D64QJIFA18L4KQKALB5EM2PB8======",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base32hex -
				encoded: "40GI48P44KJ2EA1958LIOB9E5ST3MF1T7OVK0MQSBLF5UO3RFHUNS===",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base32HexEncode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase32HexDecode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "60OJ4CPK6KR3EE1P",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "C5H66P35CPJMGQBADDM6QRJFE1ON4SRKELR7EU3PF8======",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "85146H258P3KGIAA9D64QJIFA18L4KQKALB5EM2PB8======",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "40GI48P44KJ2EA1958LIOB9E5ST3MF1T7OVK0MQSBLF5UO3RFHUNS===",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase32,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base32HexDecode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}
func TestBase32HexEscapedEncode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "60SM4DTN6NV3GG1T",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "D5K66T35DTMQJUCBFFQ6UVMHG1SR4WVNGPV7GY3TH8======",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "85146K258T3NJLBB9F64UMLHB18P4NUNBPC5GQ2TC8======",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				encoded: "40JL48T44NM2GB1958PLSC9G5WX3QH1X7SZN0QUWCPH5YS3VHKYRW===",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base32HexEscapedEncode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase32HexEscapedDecode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "60SM4DTN6NV3GG1T",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "D5K66T35DTMQJUCBFFQ6UVMHG1SR4WVNGPV7GY3TH8======",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "85146K258T3NJLBB9F64UMLHB18P4NUNBPC5GQ2TC8======",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "40JL48T44NM2GB1958PLSC9G5WX3QH1X7SZN0QUWCPH5YS3VHKYRW===",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase32,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base32HexEscapedDecode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase64Encode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "MDEyMzQ1Njc4OQ==",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base32 -
				encoded: "ICEiIyQlJicoKSorLC0uLzo7PD0+P0BbXF1eX2B7fH1+",
			},
		),
		gen(
			"japanese input (contains '+/')",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("このtest は、+/の記号を含む"),
			},
			&action{
				encoded: "44GT44GudGVzdCDjga/jgIErL+OBruiomOWPt+OCkuWQq+OCgA==",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base64Encode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase64Decode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "MDEyMzQ1Njc4OQ==",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "ICEiIyQlJicoKSorLC0uLzo7PD0+P0BbXF1eX2B7fH1+",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"encoded japanese (contains '+/')",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "44GT44GudGVzdCDjga/jgIErL+OBruiomOWPt+OCkuWQq+OCgA==",
			},
			&action{
				decoded: []byte("このtest は、+/の記号を含む"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase64,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base64Decode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase64RawEncode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "MDEyMzQ1Njc4OQ",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base32 -
				encoded: "ICEiIyQlJicoKSorLC0uLzo7PD0+P0BbXF1eX2B7fH1+",
			},
		),
		gen(
			"japanese input (contains '+/')",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("このtest は、+/の記号を含む"),
			},
			&action{
				encoded: "44GT44GudGVzdCDjga/jgIErL+OBruiomOWPt+OCkuWQq+OCgA",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base64RawEncode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase64RawDecode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "MDEyMzQ1Njc4OQ",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "ICEiIyQlJicoKSorLC0uLzo7PD0+P0BbXF1eX2B7fH1+",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"encoded japanese (contains '+/')",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "44GT44GudGVzdCDjga/jgIErL+OBruiomOWPt+OCkuWQq+OCgA",
			},
			&action{
				decoded: []byte("このtest は、+/の記号を含む"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase64,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base64RawDecode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase64URLEncode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		// expected value can be generated by the following command on a linux.
		// echo -n "0123456789" | basenc --base64url -
		// echo -n "0123456789" | base64 | tr '/+' '_-' | tr -d '='
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "MDEyMzQ1Njc4OQ==",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base32 -
				encoded: "ICEiIyQlJicoKSorLC0uLzo7PD0-P0BbXF1eX2B7fH1-",
			},
		),
		gen(
			"japanese input (contains '+/')",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("このtest は、-_の記号を含む"),
			},
			&action{
				encoded: "44GT44GudGVzdCDjga_jgIEtX-OBruiomOWPt-OCkuWQq-OCgA==",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base64URLEncode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase64URLDecode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "MDEyMzQ1Njc4OQ==",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "ICEiIyQlJicoKSorLC0uLzo7PD0-P0BbXF1eX2B7fH1-",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"encoded japanese (contains '+/')",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "44GT44GudGVzdCDjga_jgIEtX-OBruiomOWPt-OCkuWQq-OCgA==",
			},
			&action{
				decoded: []byte("このtest は、-_の記号を含む"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase64,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base64URLDecode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestBase64RawURLEncode(t *testing.T) {
	type condition struct {
		src []byte
	}

	type action struct {
		// expected value can be generated by the following command on a linux.
		// "=" prefies are removed when raw encoding.
		// echo -n "0123456789" | basenc --base64url -
		// echo -n "0123456789" | base64 | tr '/+' '_-' | tr -d '='
		encoded string
	}

	CndSetBytes := "set non zero-length bytes"
	CndSetNil := "set nil"
	actCheckEmpty := "empty string"
	actCheckExpected := "expected value returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndSetBytes, "set non nil or non zero-length bytes array")
	tb.Condition(CndSetNil, "set nil value as an argument")
	tb.Action(actCheckEmpty, "check that an empty string returned")
	tb.Action(actCheckExpected, "Check that an expected value (non nil) returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"numbers byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("0123456789"),
			},
			&action{
				encoded: "MDEyMzQ1Njc4OQ",
			},
		),
		gen(
			"alphabet byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
			&action{
				encoded: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo",
			},
		),
		gen(
			"capital byte input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			&action{
				encoded: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo",
			},
		),
		gen(
			"ascii input",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
			&action{
				// echo -n ' !"#$%&'\''()*+,-./:;<=>?@[''\'']^_`{|}~' | basenc --base32 -
				encoded: "ICEiIyQlJicoKSorLC0uLzo7PD0-P0BbXF1eX2B7fH1-",
			},
		),
		gen(
			"japanese input (contains '+/')",
			[]string{CndSetBytes},
			[]string{actCheckExpected},
			&condition{
				src: []byte("このtest は、-_の記号を含む"),
			},
			&action{
				encoded: "44GT44GudGVzdCDjga_jgIEtX-OBruiomOWPt-OCkuWQq-OCgA",
			},
		),
		gen(
			"zero length byte input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: []byte(""),
			},
			&action{
				encoded: "",
			},
		),
		gen(
			"nil input",
			[]string{CndSetNil},
			[]string{actCheckEmpty},
			&condition{
				src: nil,
			},
			&action{
				encoded: "",
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got := Base64RawURLEncode(tt.C().src)
			testutil.Diff(t, tt.A().encoded, got)
		})
	}
}

func TestBase64RawURLDecode(t *testing.T) {
	type condition struct {
		src string
	}

	type action struct {
		decoded []byte
		err     error
	}

	CndValid := "valid string"
	CndInvalid := "invalid string"
	actCheckEmptySlice := "empty slice"
	actCheckExpected := "expected value returned"
	actCheckNoError := "no error"
	actCheckError := "expected error returned"

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	tb.Condition(CndValid, "give a valid encoded string")
	tb.Condition(CndInvalid, "give an invalid encoded string")
	tb.Action(actCheckExpected, "Check that an expected value returned")
	tb.Action(actCheckEmptySlice, "check that an empty slice was returned")
	tb.Action(actCheckNoError, "Check that returned error is nil")
	tb.Action(actCheckError, "Check that an expected error was returned")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"encoded numbers",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "MDEyMzQ1Njc4OQ",
			},
			&action{
				decoded: []byte("0123456789"),
			},
		),
		gen(
			"encoded alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo",
			},
			&action{
				decoded: []byte("abcdefghijklmnopqrstuvwxyz"),
			},
		),
		gen(
			"encoded capital alphabet",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo",
			},
			&action{
				decoded: []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
		),
		gen(
			"encoded ascii",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "ICEiIyQlJicoKSorLC0uLzo7PD0-P0BbXF1eX2B7fH1-",
			},
			&action{
				decoded: []byte(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"),
			},
		),
		gen(
			"encoded japanese (contains '+/')",
			[]string{CndValid},
			[]string{actCheckExpected, actCheckNoError},
			&condition{
				src: "44GT44GudGVzdCDjga_jgIEtX-OBruiomOWPt-OCkuWQq-OCgA",
			},
			&action{
				decoded: []byte("このtest は、-_の記号を含む"),
			},
		),
		gen(
			"empty string",
			[]string{CndValid},
			[]string{actCheckEmptySlice, actCheckNoError},
			&condition{
				src: "",
			},
			&action{
				decoded: []byte{},
			},
		),
		gen(
			"invalid encoded",
			[]string{CndInvalid},
			[]string{actCheckEmptySlice, actCheckError},
			&condition{
				src: "invalid encoded string",
			},
			&action{
				decoded: nil,
				err: &er.Error{
					Package:     ErrPkg,
					Type:        ErrTypeBase64,
					Description: ErrDscDecode,
				},
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			got, err := Base64RawURLDecode(tt.C().src)
			testutil.Diff(t, tt.A().decoded, got)
			testutil.Diff(t, tt.A().err, err, cmpopts.EquateErrors())
		})
	}
}

func TestEncoderDecoder(t *testing.T) {
	type condition struct {
		typ k.EncodingType
	}

	type action struct {
		enc     EncodeToStringFunc
		dec     DecodeStringFunc
		pattern *regexp.Regexp
	}

	tb := testutil.NewTableBuilder[*condition, *action]()
	tb.Name(t.Name())
	cndValidType := tb.Condition("valid type", "input a valid encode type")
	cndUnknown := tb.Condition("unknown type", "input a invalid encode type")
	actCheckEncoder := tb.Action("check encoder", "check the returned encoder")
	table := tb.Build()

	gen := testutil.NewCase[*condition, *action]
	testCases := []*testutil.Case[*condition, *action]{
		gen(
			"Base32",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base32,
			},
			&action{
				enc:     base32.StdEncoding.EncodeToString,
				dec:     base32.StdEncoding.DecodeString,
				pattern: regexp.MustCompile("^[A-Z2-7=]+$"),
			},
		),
		gen(
			"Base32Hex",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base32Hex,
			},
			&action{
				enc:     base32.HexEncoding.EncodeToString,
				dec:     base32.HexEncoding.DecodeString,
				pattern: regexp.MustCompile("^[0-9A-V=]+$"),
			},
		),
		gen(
			"Base32Escaped",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base32Escaped,
			},
			&action{
				enc:     Base32StdEscapedEncoding.EncodeToString,
				dec:     Base32StdEscapedEncoding.DecodeString,
				pattern: regexp.MustCompile("^[BCDFGHJKLMNPQRSTUVWXYZ0-9=]+$"),
			},
		),
		gen(
			"Base32HexEscaped",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base32HexEscaped,
			},
			&action{
				enc:     Base32HexEscapedEncoding.EncodeToString,
				dec:     Base32HexEscapedEncoding.DecodeString,
				pattern: regexp.MustCompile("^[0-9BCDFGHJKLMNPQRSTUVWXYZ=]+$"),
			},
		),
		gen(
			"Base64",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base64,
			},
			&action{
				enc:     base64.StdEncoding.EncodeToString,
				dec:     base64.StdEncoding.DecodeString,
				pattern: regexp.MustCompile("^[A-Za-z0-9+/=]+$"),
			},
		),
		gen(
			"Base64Raw",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base64Raw,
			},
			&action{
				enc:     base64.RawStdEncoding.EncodeToString,
				dec:     base64.RawStdEncoding.DecodeString,
				pattern: regexp.MustCompile("^[A-Za-z0-9+/]+$"),
			},
		),
		gen(
			"Base64URL",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base64URL,
			},
			&action{
				enc:     base64.URLEncoding.EncodeToString,
				dec:     base64.URLEncoding.DecodeString,
				pattern: regexp.MustCompile("^[A-Za-z0-9-_=]+$"),
			},
		),
		gen(
			"Base64RawURL",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base64RawURL,
			},
			&action{
				enc:     base64.RawURLEncoding.EncodeToString,
				dec:     base64.RawURLEncoding.DecodeString,
				pattern: regexp.MustCompile("^[A-Za-z0-9-_]+$"),
			},
		),
		gen(
			"Base16",
			[]string{cndValidType},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_Base16,
			},
			&action{
				enc:     hex.EncodeToString,
				dec:     hex.DecodeString,
				pattern: regexp.MustCompile("^[0-9a-f]+$"),
			},
		),
		gen(
			"Unknown will be Base32HexEscaped",
			[]string{cndUnknown},
			[]string{actCheckEncoder},
			&condition{
				typ: k.EncodingType_EncodingTypeUnknown,
			},
			&action{
				enc:     Base32StdEscapedEncoding.EncodeToString,
				dec:     Base32StdEscapedEncoding.DecodeString,
				pattern: regexp.MustCompile("^[0-9BCDFGHJKLMNPQRSTUVWXYZ=]+$"),
			},
		),
	}

	testutil.Register(table, testCases...)

	for _, tt := range table.Entries() {
		tt := tt
		t.Run(tt.Name(), func(t *testing.T) {
			enc, dec := EncoderDecoder(tt.C().typ)
			testutil.Diff(t, tt.A().enc, enc, cmp.Comparer(testutil.ComparePointer[EncodeToStringFunc]))
			testutil.Diff(t, tt.A().dec, dec, cmp.Comparer(testutil.ComparePointer[DecodeStringFunc]))

			data := "abcdefghijklmnopqrstuvwxyz1234 !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
			e := enc([]byte(data))
			fmt.Println(tt.Name(), e)
			testutil.Diff(t, true, tt.A().pattern.MatchString(e))
			d, err := dec(e)
			testutil.Diff(t, nil, err)
			testutil.Diff(t, data, string(d))
		})
	}
}
