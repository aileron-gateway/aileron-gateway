package errorutil

import (
	"bytes"
	"fmt"
	"regexp"
	"slices"
	"strconv"
)

const (
	tplValue = iota
	tplTag
)

// newTemplate returns a new instance of error message template.
// Returned value is always non-nil and ready to use.
func newTemplate(tpl string) *template {
	exp := []byte(tpl)
	reg := regexp.MustCompile(`\{\{ *[0-9a-zA-Z_\-\.]+ *\}\}`)
	indexes := reg.FindAllIndex(exp, -1)

	types := []int{}
	values := [][]byte{}

	pos := 0
	for _, ids := range indexes {
		if ids[0] > pos {
			types = append(types, tplValue)
			values = append(values, exp[pos:ids[0]])
		}
		types = append(types, tplTag)
		values = append(values, bytes.Trim(exp[ids[0]+2:ids[1]-2], " "))
		pos = ids[1]
	}
	if pos < len(exp) {
		types = append(types, 0)
		values = append(values, exp[pos:])
	}

	return &template{
		valTypes: slices.Clip(types),
		values:   slices.Clip(values),
	}
}

// template is the template object used for generating
// error messages.
// Length of the valueTypes and values have the same length.
//
// For example,
// template "Her name is {{name}}!!" will result in
// the following template object.
// Here we assume "{{" and "}}" as the tag bracket.
// A value corresponding to the tag {{name}} should be given
// at execute time.
//
//	types []int | values [][]byte
//	[           |  [
//	 tplValue,  |   []byte("Her name is "),
//	 tplTag,    |   []byte("name"),
//	 tplValue,  |   []byte("!!"),
//	]           |  ]
type template struct {
	valTypes []int
	values   [][]byte
}

// execute executes the template.
// execute writes generated bytes from the template to the
// given buffer. The first argument buf must not be nil, otherwise panics.
// Second argument m can be nil even the template has tags.
func (t *template) execute(buf *bytes.Buffer, m map[string]any) {
	mv := mapVal(m)
	for i := range t.valTypes {
		switch t.valTypes[i] {
		case tplValue:
			buf.Write(t.values[i])
		case tplTag:
			buf.Write(mv.tagValue(string(t.values[i])))
		}
	}
}

// mapVal adds a tag func func(tag string) []byte
// to the map[string]any.
// The tag func is intended to be used in the template.
type mapVal map[string]any

func (m mapVal) tagValue(tag string) []byte {
	if m == nil {
		return nil
	}
	val, ok := m[tag]
	if !ok {
		return nil
	}
	switch v := val.(type) {
	case nil:
		return []byte("<nil>")
	case string:
		return []byte(v)
	case []byte:
		return v
	case int:
		return []byte(strconv.FormatInt(int64(v), 10))
	case int32:
		return []byte(strconv.FormatInt(int64(v), 10))
	case int64:
		return []byte(strconv.FormatInt(v, 10))
	case float32:
		return []byte(strconv.FormatFloat(float64(v), 'f', -1, 32))
	case float64:
		return []byte(strconv.FormatFloat(float64(v), 'f', -1, 64))
	default:
		return []byte(fmt.Sprint(v)) // "%+v"
	}
}
